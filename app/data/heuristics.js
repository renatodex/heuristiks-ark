export const categories = [
  { id: 'complexity', name: 'Complexidade', color: '#8b5cf6', emoji: 'üß†' },
  { id: 'management', name: 'Gest√£o', color: '#06b6d4', emoji: 'üìä' },
  { id: 'design', name: 'Design de C√≥digo', color: '#ec4899', emoji: 'üé®' },
  { id: 'architecture', name: 'Arquitetura', color: '#fbbf24', emoji: 'üèóÔ∏è' },
  { id: 'team', name: 'Trabalho em Equipe', color: '#10b981', emoji: 'üë•' },
];

export const heuristics = [
  {
    id: 'cognitive-complexity',
    title: 'Cognitive Complexity',
    subtitle: 'Esfor√ßo mental necess√°rio para entender algo',
    category: 'complexity',
    icon: 'FaBrain',
    shortDescription: 'Mede o qu√£o dif√≠cil √© entender um peda√ßo de c√≥digo ou sistema.',
    inventor: 'G. Ann Campbell',
    year: '2016',
    history: 'Criada pela SonarSource para melhorar a medi√ß√£o de complexidade de c√≥digo, focando no esfor√ßo cognitivo real necess√°rio para entender o c√≥digo, ao inv√©s de apenas contar caminhos como a complexidade ciclom√°tica. G. Ann Campbell percebeu que nem todas as estruturas de c√≥digo s√£o igualmente dif√≠ceis de entender.',
    purpose: 'Avaliar o qu√£o dif√≠cil √© para um humano entender um peda√ßo de c√≥digo, ajudando a identificar √°reas que precisam de refatora√ß√£o.',
    eli5: 'Imagina que voc√™ est√° montando um quebra-cabe√ßa. Alguns quebra-cabe√ßas s√£o f√°ceis de entender s√≥ de olhar, outros precisam que voc√™ pense muito. Cognitive Complexity mede o quanto voc√™ precisa pensar para entender um c√≥digo.',
    detailed: 'Cognitive Complexity √© uma m√©trica moderna que avalia o qu√£o dif√≠cil √© para um humano entender um peda√ßo de c√≥digo. Diferente da Complexidade Ciclom√°tica que conta todos os caminhos poss√≠veis, a Cognitive Complexity ignora estruturas que s√£o naturalmente f√°ceis de entender (como sequ√™ncias simples) e penaliza mais pesadamente estruturas confusas (como ifs aninhados). A m√©trica aumenta quando h√°: breaks no fluxo linear, estruturas aninhadas, e recurs√£o.',
    relatedHeuristics: ['cyclomatic-complexity', 'code-churn'],
    youtubeVideos: [
      { title: 'Cognitive Complexity - A new way of measuring understandability', url: 'https://www.youtube.com/watch?v=el9OKGrqU6o' },
    ],
    sources: [
      { title: 'Paper original - Cognitive Complexity: A new way of measuring understandability', url: 'https://www.sonarsource.com/resources/cognitive-complexity/' },
      { title: 'SonarSource - Documenta√ß√£o oficial', url: 'https://www.sonarsource.com/docs/CognitiveComplexity.pdf' },
    ],
  },
  {
    id: 'cyclomatic-complexity',
    title: 'Cyclomatic Complexity',
    subtitle: 'N√∫mero de caminhos independentes atrav√©s do c√≥digo',
    category: 'complexity',
    icon: 'FaRoute',
    shortDescription: 'Mede a quantidade de caminhos diferentes que o c√≥digo pode seguir.',
    inventor: 'Thomas J. McCabe',
    year: '1976',
    history: 'Thomas McCabe desenvolveu esta m√©trica para medir a complexidade estrutural de um programa. Ele percebeu que quanto mais caminhos poss√≠veis um c√≥digo tinha, mais dif√≠cil era test√°-lo e mant√™-lo. Publicou o paper "A Complexity Measure" que se tornou refer√™ncia.',
    purpose: 'Medir a complexidade estrutural do c√≥digo e estimar o n√∫mero de testes necess√°rios para cobertura completa.',
    eli5: 'Imagina um labirinto. Quantas escolhas diferentes voc√™ tem que fazer para sair? Cada escolha √© como um "if" no c√≥digo. Quanto mais escolhas, mais complicado fica!',
    detailed: 'A Complexidade Ciclom√°tica conta o n√∫mero de caminhos linearmente independentes atrav√©s do c√≥digo. √â calculada analisando o grafo de controle de fluxo do programa. Um valor alto indica que o c√≥digo tem muitos caminhos de execu√ß√£o, tornando-o dif√≠cil de testar e manter. A f√≥rmula √©: M = E - N + 2P, onde E = arestas, N = n√≥s, P = componentes conectados. Valores acima de 10 s√£o considerados complexos.',
    relatedHeuristics: ['cognitive-complexity'],
    youtubeVideos: [],
    sources: [
      { title: 'Paper original - A Complexity Measure (Thomas McCabe, 1976)', url: 'https://www.literateprogramming.com/mccabe.pdf' },
      { title: 'Wikipedia - Cyclomatic Complexity', url: 'https://en.wikipedia.org/wiki/Cyclomatic_complexity' },
    ],
  },
  {
    id: 'bike-shedding',
    title: 'Bike Shedding',
    subtitle: 'Lei da trivialidade - perder tempo com detalhes pequenos',
    category: 'management',
    icon: 'FaBicycle',
    shortDescription: 'Tend√™ncia de gastar muito tempo em decis√µes triviais e pouco tempo em decis√µes importantes.',
    inventor: 'C. Northcote Parkinson',
    year: '1957',
    history: 'Parkinson usou o exemplo de um comit√™ que gastou muito tempo discutindo a cor de um bike shed (estacionamento de bicicletas), mas aprovou rapidamente a constru√ß√£o de uma usina nuclear. As pessoas se sentem mais confort√°veis debatendo t√≥picos simples que todos entendem, evitando decis√µes complexas.',
    purpose: 'Alertar sobre a tend√™ncia de focar energia em decis√µes triviais ao inv√©s de quest√µes realmente importantes.',
    eli5: 'Imagina que voc√™ vai construir um castelo e um lugar para guardar sua bicicleta. A√≠ voc√™ passa 5 minutos decidindo sobre o castelo e 2 horas discutindo de que cor pintar o lugar da bicicleta! Isso √© Bike Shedding.',
    detailed: 'O Bike Shedding (ou Lei da Trivialidade) √© um fen√¥meno onde grupos gastam tempo desproporcional em quest√µes triviais que todos entendem, enquanto decis√µes complexas e importantes s√£o aprovadas rapidamente porque poucas pessoas se sentem qualificadas para opinar. Em projetos de software, isso se manifesta em longas discuss√µes sobre indenta√ß√£o, nomes de vari√°veis ou cores de UI, enquanto decis√µes arquiteturais cr√≠ticas passam sem debate adequado.',
    relatedHeuristics: ['parkinsons-law'],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Law of Triviality (Bike-shedding)', url: 'https://en.wikipedia.org/wiki/Law_of_triviality' },
      { title: 'Parkinson\'s Law - The book', url: 'https://en.wikipedia.org/wiki/Parkinson%27s_law' },
    ],
  },
  {
    id: 'code-churn',
    title: 'Code Churn',
    subtitle: 'Rotatividade de c√≥digo - quanto o c√≥digo muda',
    category: 'complexity',
    icon: 'FaSync',
    shortDescription: 'Mede quanto o c√≥digo est√° sendo modificado, reescrito ou deletado ao longo do tempo.',
    inventor: 'Comunidade de Software Engineering',
    year: 'Anos 90',
    history: 'O conceito surgiu quando times come√ßaram a usar sistemas de controle de vers√£o e perceberam que c√≥digo que muda muito frequentemente tende a ter mais bugs e ser menos est√°vel.',
    purpose: 'Identificar √°reas do c√≥digo que s√£o inst√°veis e podem ter problemas de design ou requisitos mal definidos.',
    eli5: 'Se voc√™ escreve uma hist√≥ria e fica mudando ela toda hora, arriscando rasgar o papel, √© sinal que voc√™ n√£o tinha certeza do que queria escrever. C√≥digo que muda muito pode estar confuso.',
    detailed: 'Code Churn mede a volatilidade do c√≥digo atrav√©s da quantidade de linhas adicionadas, modificadas e removidas em um per√≠odo. Alto churn pode indicar: incerteza nos requisitos, problemas de design, c√≥digo experimental, ou simplesmente trabalho ativo. Analisar churn junto com bugs ajuda a identificar √°reas problem√°ticas do c√≥digo.',
    relatedHeuristics: ['shotgun-surgery', 'change-amplification'],
    youtubeVideos: [],
    sources: [
      { title: 'Microsoft Research - Code Churn and Bugs', url: 'https://www.microsoft.com/en-us/research/publication/predicting-bugs-from-history/' },
      { title: 'Article - Understanding Code Churn', url: 'https://linearb.io/blog/what-is-code-churn' },
    ],
  },
  {
    id: 'parkinsons-law',
    title: 'Parkinson\'s Law',
    subtitle: 'O trabalho se expande para preencher o tempo dispon√≠vel',
    category: 'management',
    icon: 'FaClock',
    shortDescription: 'Se voc√™ tem 2 horas para fazer algo, vai levar 2 horas. Se tem 2 dias, vai levar 2 dias.',
    inventor: 'C. Northcote Parkinson',
    year: '1955',
    history: 'Cyril Parkinson observou na burocracia brit√¢nica que o trabalho se expandia para preencher o tempo dispon√≠vel, independentemente da quantidade real de trabalho necess√°ria. Ele publicou isso em um ensaio sat√≠rico no The Economist que se tornou um princ√≠pio reconhecido de gest√£o.',
    purpose: 'Conscientizar sobre a tend√™ncia de usar todo o tempo dispon√≠vel, mesmo quando a tarefa poderia ser conclu√≠da mais rapidamente.',
    eli5: 'Se sua m√£e te d√° 1 hora para arrumar o quarto, voc√™ leva 1 hora. Se ela te d√° o dia todo, voc√™ vai enrolar e levar o dia todo!',
    detailed: 'A Lei de Parkinson afirma que o trabalho se expande para preencher o tempo dispon√≠vel para sua conclus√£o. Isso acontece porque tendemos a usar todo o tempo dado, mesmo que possamos terminar mais r√°pido. Em desenvolvimento de software, isso se manifesta em estimativas infladas, features desnecessariamente complexas, e procrastina√ß√£o. A solu√ß√£o √© criar prazos mais apertados (mas realistas) e dividir trabalho em tarefas menores.',
    relatedHeuristics: ['bike-shedding'],
    youtubeVideos: [],
    sources: [
      { title: 'Ensaio original - Parkinson\'s Law (The Economist, 1955)', url: 'https://www.economist.com/news/1955/11/19/parkinsons-law' },
      { title: 'Wikipedia - Parkinson\'s Law', url: 'https://en.wikipedia.org/wiki/Parkinson%27s_law' },
    ],
  },
  {
    id: 'brooks-law',
    title: 'Brooks\' Law',
    subtitle: 'Adicionar pessoas a um projeto atrasado o atrasa ainda mais',
    category: 'management',
    icon: 'FaUsers',
    shortDescription: 'Colocar mais gente n√£o necessariamente aumenta a velocidade.',
    inventor: 'Fred Brooks',
    year: '1975',
    history: 'Fred Brooks observou isso no projeto OS/360 da IBM. Quando o projeto atrasou, mais programadores foram adicionados, mas isso s√≥ piorou as coisas. Ele documentou isso no livro cl√°ssico "The Mythical Man-Month".',
    purpose: 'Alertar que adicionar mais pessoas a um projeto pode aumentar a complexidade e a sobrecarga de comunica√ß√£o.',
    eli5: 'Se 1 pessoa leva 1 hora para comer um bolo, 60 pessoas n√£o v√£o comer o bolo em 1 minuto! √Äs vezes, muita gente junto s√≥ atrapalha.',
    detailed: 'A Lei de Brooks explica por que adicionar desenvolvedores a um projeto atrasado geralmente piora a situa√ß√£o. Novos membros precisam ser treinados, aumentam a sobrecarga de comunica√ß√£o (canais de comunica√ß√£o crescem exponencialmente), e podem introduzir mais bugs enquanto aprendem. A comunica√ß√£o entre N pessoas requer N(N-1)/2 canais. Em vez de adicionar pessoas, √© melhor reduzir escopo ou repensar a arquitetura.',
    relatedHeuristics: ['bus-factor', 'conways-law'],
    youtubeVideos: [],
    sources: [
      { title: 'Livro - The Mythical Man-Month (Fred Brooks)', url: 'https://en.wikipedia.org/wiki/The_Mythical_Man-Month' },
      { title: 'Wikipedia - Brooks\' Law', url: 'https://en.wikipedia.org/wiki/Brooks%27s_law' },
    ],
  },
  {
    id: 'idempotence',
    title: 'Idempot√™ncia',
    subtitle: 'Fazer a mesma coisa v√°rias vezes d√° o mesmo resultado',
    category: 'architecture',
    icon: 'FaRepeat',
    shortDescription: 'Uma opera√ß√£o √© idempotente se execut√°-la m√∫ltiplas vezes produz o mesmo resultado.',
    inventor: 'Conceito Matem√°tico',
    year: 'S√©culo 19',
    history: 'O conceito vem da matem√°tica, mas foi adotado pela computa√ß√£o. √â especialmente importante em sistemas distribu√≠dos onde mensagens podem ser duplicadas ou retransmitidas.',
    purpose: 'Garantir que opera√ß√µes possam ser repetidas sem efeitos colaterais indesejados.',
    eli5: 'Apertar o bot√£o de ligar a luz. Se a luz j√° est√° acesa e voc√™ aperta de novo, ela continua acesa (n√£o fica "mais acesa"). Isso √© idempot√™ncia!',
    detailed: 'Idempot√™ncia significa que executar uma opera√ß√£o uma ou m√∫ltiplas vezes produz o mesmo resultado. Em APIs REST, m√©todos GET, PUT e DELETE devem ser idempotentes. Por exemplo, deletar um recurso uma vez ou dez vezes deixa o sistema no mesmo estado (recurso deletado). Isso √© crucial para sistemas que precisam retransmitir opera√ß√µes, pois garante que duplicatas n√£o causem efeitos colaterais indesejados.',
    relatedHeuristics: [],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Idempotence', url: 'https://en.wikipedia.org/wiki/Idempotence' },
      { title: 'MDN - Idempotent HTTP Methods', url: 'https://developer.mozilla.org/en-US/docs/Glossary/Idempotent' },
      { title: 'RFC 7231 - HTTP/1.1 Semantics (Section on Idempotent Methods)', url: 'https://tools.ietf.org/html/rfc7231#section-4.2.2' },
    ],
  },
  {
    id: 'pareto-principle',
    title: 'Pareto Principle',
    subtitle: '80/20 - Foque nos 20% que geram 80% do resultado',
    category: 'management',
    icon: 'FaChartLine',
    shortDescription: '80% dos efeitos v√™m de 20% das causas.',
    inventor: 'Vilfredo Pareto',
    year: '1896',
    history: 'Vilfredo Pareto, economista italiano, observou que 80% das terras na It√°lia pertenciam a 20% da popula√ß√£o. Depois percebeu que esse padr√£o se repetia em muitos lugares: 80% das ervilhas vinham de 20% das vagens em seu jardim!',
    purpose: 'Priorizar esfor√ßos nas √°reas que geram maior impacto.',
    eli5: 'Se voc√™ tem 10 brinquedos mas brinca mesmo com s√≥ 2, esses 2 (20%) te d√£o quase toda a divers√£o (80%). Foque no que realmente importa!',
    detailed: 'O Princ√≠pio de Pareto afirma que, em muitos casos, aproximadamente 80% dos efeitos v√™m de 20% das causas. Em software: 80% dos bugs est√£o em 20% do c√≥digo, 80% do uso vem de 20% das features, 80% do tempo √© gasto em 20% das tarefas. Use isso para priorizar esfor√ßos: identifique e foque nos 20% mais impactantes.',
    relatedHeuristics: [],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Pareto Principle', url: 'https://en.wikipedia.org/wiki/Pareto_principle' },
      { title: 'Livro - The 80/20 Principle (Richard Koch)', url: 'https://www.goodreads.com/book/show/181206.The_80_20_Principle' },
    ],
  },
  {
    id: 'overengineering',
    title: 'Overengineering',
    subtitle: 'Fazer algo mais complicado do que precisa ser',
    category: 'design',
    icon: 'FaCog',
    shortDescription: 'Criar solu√ß√µes excessivamente complexas para problemas simples.',
    inventor: 'Conceito da Engenharia',
    year: 'N/A',
    history: 'O termo vem da engenharia tradicional, onde projetar algo com mais recursos ou complexidade do que o necess√°rio aumenta custos e reduz confiabilidade. Em software, manifesta-se como abstra√ß√µes prematuras e arquiteturas excessivamente complexas.',
    purpose: 'Alertar contra a tenta√ß√£o de criar solu√ß√µes mais complexas que o necess√°rio.',
    eli5: '√â como usar um rob√¥ gigante com 50 bot√µes s√≥ para abrir uma porta. As vezes, s√≥ girar a ma√ßaneta j√° resolve!',
    detailed: 'Overengineering acontece quando criamos solu√ß√µes mais complexas do que o problema requer. Exemplos: criar abstra√ß√µes para c√≥digo usado uma √∫nica vez, implementar padr√µes de design desnecess√°rios, otimizar prematuramente, ou construir "flexibility" que nunca ser√° usada. O custo √© c√≥digo mais dif√≠cil de entender e manter. A solu√ß√£o √© come√ßar simples e adicionar complexidade apenas quando necess√°rio (YAGNI - You Aren\'t Gonna Need It).',
    relatedHeuristics: ['srp'],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Overengineering', url: 'https://en.wikipedia.org/wiki/Overengineering' },
      { title: 'Article - YAGNI Principle', url: 'https://martinfowler.com/bliki/Yagni.html' },
    ],
  },
  {
    id: 'srp',
    title: 'Single Responsibility Principle',
    subtitle: 'Cada coisa faz s√≥ uma tarefa',
    category: 'design',
    icon: 'FaBullseye',
    shortDescription: 'Uma classe/fun√ß√£o deve ter apenas uma raz√£o para mudar.',
    inventor: 'Robert C. Martin (Uncle Bob)',
    year: '2000',
    history: 'Uncle Bob formulou o SRP como parte dos princ√≠pios SOLID. Ele percebeu que c√≥digo que faz muitas coisas diferentes muda com frequ√™ncia e por raz√µes diferentes, tornando-se fr√°gil.',
    purpose: 'Manter o c√≥digo focado e f√°cil de manter, com cada m√≥dulo tendo uma √∫nica responsabilidade.',
    eli5: 'Uma tesoura corta, um l√°pis escreve. Se voc√™ tentar fazer uma tesoura que tamb√©m escreve, vai ficar ruim nas duas coisas!',
    detailed: 'O Princ√≠pio da Responsabilidade √önica afirma que uma classe deve ter apenas uma raz√£o para mudar, ou seja, apenas uma responsabilidade. Isso n√£o significa fazer apenas uma coisa, mas que todas as coisas que faz devem estar relacionadas a uma √∫nica responsabilidade. Exemplo ruim: uma classe User que valida, persiste e envia email. Exemplo bom: User, UserValidator, UserRepository, EmailService.',
    relatedHeuristics: ['ocp', 'lsp', 'isp', 'dip'],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - SOLID Principles', url: 'https://en.wikipedia.org/wiki/SOLID' },
      { title: 'Uncle Bob - The Single Responsibility Principle', url: 'https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html' },
    ],
  },
  {
    id: 'ocp',
    title: 'Open/Closed Principle',
    subtitle: 'Aberto para extens√£o, fechado para modifica√ß√£o',
    category: 'design',
    icon: 'FaUnlockAlt',
    shortDescription: 'Voc√™ deve poder adicionar funcionalidades sem modificar c√≥digo existente.',
    inventor: 'Bertrand Meyer',
    year: '1988',
    history: 'Bertrand Meyer introduziu este princ√≠pio em seu livro "Object-Oriented Software Construction". A ideia √© que software deve ser est√°vel (fechado para modifica√ß√£o) mas flex√≠vel (aberto para extens√£o).',
    purpose: 'Permitir que o c√≥digo seja estendido sem modificar implementa√ß√µes existentes.',
    eli5: '√â como ter um bloco de Lego. Voc√™ n√£o quebra o bloco para mud√°-lo, voc√™ encaixa novos blocos nele!',
    detailed: 'O Princ√≠pio Aberto/Fechado diz que entidades de software devem estar abertas para extens√£o mas fechadas para modifica√ß√£o. Isso significa que podemos adicionar novos comportamentos sem alterar c√≥digo existente, reduzindo o risco de bugs. Isso √© alcan√ßado atrav√©s de abstra√ß√µes (interfaces, classes abstratas) e polimorfismo. Exemplo: em vez de um switch-case gigante, use uma interface e diferentes implementa√ß√µes.',
    relatedHeuristics: ['srp', 'lsp', 'isp', 'dip'],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Open/Closed Principle', url: 'https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle' },
      { title: 'Livro - Object-Oriented Software Construction (Bertrand Meyer)', url: 'https://www.goodreads.com/book/show/946123.Object_Oriented_Software_Construction' },
    ],
  },
  {
    id: 'lsp',
    title: 'Liskov Substitution Principle',
    subtitle: 'Subtipos devem ser substitu√≠veis por seus tipos base',
    category: 'design',
    icon: 'FaExchangeAlt',
    shortDescription: 'Se voc√™ trocar uma pe√ßa, o sistema ainda deve funcionar.',
    inventor: 'Barbara Liskov',
    year: '1987',
    history: 'Barbara Liskov apresentou este conceito em uma confer√™ncia. Ela percebeu que a heran√ßa s√≥ faz sentido quando o subtipo pode realmente substituir o tipo base sem quebrar o programa.',
    purpose: 'Garantir que a heran√ßa seja usada corretamente, mantendo o comportamento esperado.',
    eli5: 'Se voc√™ tem um brinquedo que usa pilhas, qualquer pilha do tamanho certo deve funcionar. N√£o importa a marca!',
    detailed: 'O Princ√≠pio da Substitui√ß√£o de Liskov afirma que objetos de uma classe base devem ser substitu√≠veis por objetos de suas subclasses sem quebrar o programa. Isso significa que subclasses devem respeitar o contrato da classe base: mesmas pr√©-condi√ß√µes (ou mais fracas), mesmas p√≥s-condi√ß√µes (ou mais fortes), e mesmas invariantes. Exemplo de viola√ß√£o: uma classe Square que herda de Rectangle e quebra a expectativa de que largura e altura s√£o independentes.',
    relatedHeuristics: ['srp', 'ocp', 'isp', 'dip'],
    youtubeVideos: [],
    sources: [
      { title: 'Paper original - Data Abstraction and Hierarchy (Barbara Liskov, 1987)', url: 'https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf' },
      { title: 'Wikipedia - Liskov Substitution Principle', url: 'https://en.wikipedia.org/wiki/Liskov_substitution_principle' },
    ],
  },
  {
    id: 'isp',
    title: 'Interface Segregation Principle',
    subtitle: 'N√£o obrigue ningu√©m a depender do que n√£o usa',
    category: 'design',
    icon: 'FaFilter',
    shortDescription: 'Interfaces devem ser espec√≠ficas para cada cliente.',
    inventor: 'Robert C. Martin (Uncle Bob)',
    year: '2000',
    history: 'Uncle Bob formulou o ISP ap√≥s observar que interfaces "gordas" (com muitos m√©todos) for√ßavam classes a implementar m√©todos que n√£o usavam, criando depend√™ncias desnecess√°rias.',
    purpose: 'Manter interfaces pequenas e focadas, evitando depend√™ncias desnecess√°rias.',
    eli5: 'Se voc√™ vai ao restaurante s√≥ para beber suco, n√£o precisa saber fazer todos os pratos do card√°pio!',
    detailed: 'O Princ√≠pio da Segrega√ß√£o de Interface afirma que nenhum cliente deve ser for√ßado a depender de m√©todos que n√£o usa. Em vez de uma interface grande com muitos m√©todos, crie interfaces menores e espec√≠ficas. Exemplo ruim: IWorker com m√©todos work() e eat(), for√ßando rob√¥s a implementar eat(). Exemplo bom: IWorkable com work() e IFeedable com eat().',
    relatedHeuristics: ['srp', 'ocp', 'lsp', 'dip'],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Interface Segregation Principle', url: 'https://en.wikipedia.org/wiki/Interface_segregation_principle' },
      { title: 'Uncle Bob - The Interface Segregation Principle', url: 'https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html' },
    ],
  },
  {
    id: 'dip',
    title: 'Dependency Inversion Principle',
    subtitle: 'Dependa de abstra√ß√µes, n√£o de implementa√ß√µes concretas',
    category: 'design',
    icon: 'FaLayerGroup',
    shortDescription: 'M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel.',
    inventor: 'Robert C. Martin (Uncle Bob)',
    year: '2000',
    history: 'Uncle Bob criou o DIP para resolver o problema de acoplamento forte entre m√≥dulos. Ele percebeu que inverter a dire√ß√£o das depend√™ncias (fazendo ambos dependerem de abstra√ß√µes) tornava o c√≥digo mais flex√≠vel.',
    purpose: 'Reduzir o acoplamento entre m√≥dulos atrav√©s de abstra√ß√µes.',
    eli5: 'Em vez de construir sua casa colada na loja de doces (se a loja fechar, voc√™ fica triste), voc√™ mora perto de "uma loja qualquer". A√≠ se uma fecha, outra pode abrir l√°!',
    detailed: 'O Princ√≠pio da Invers√£o de Depend√™ncia afirma que: 1) M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel; ambos devem depender de abstra√ß√µes. 2) Abstra√ß√µes n√£o devem depender de detalhes; detalhes devem depender de abstra√ß√µes. Isso inverte a dire√ß√£o tradicional de depend√™ncia, onde m√≥dulos de alto n√≠vel dependiam diretamente de implementa√ß√µes concretas. Use interfaces ou classes abstratas para desacoplar.',
    relatedHeuristics: ['srp', 'ocp', 'lsp', 'isp'],
    youtubeVideos: [],
    sources: [
      { title: 'Wikipedia - Dependency Inversion Principle', url: 'https://en.wikipedia.org/wiki/Dependency_inversion_principle' },
      { title: 'Uncle Bob - Dependency Inversion Principle', url: 'https://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html' },
    ],
  },
  {
    id: 'conways-law',
    title: 'Conway\'s Law',
    subtitle: 'A estrutura do sistema reflete a estrutura da organiza√ß√£o',
    category: 'architecture',
    icon: 'FaBuilding',
    shortDescription: 'Sistemas refletem a estrutura de comunica√ß√£o da organiza√ß√£o que os criou.',
    inventor: 'Melvin Conway',
    year: '1967',
    history: 'Melvin Conway observou que organiza√ß√µes que projetam sistemas s√£o constrangidas a produzir designs que s√£o c√≥pias das estruturas de comunica√ß√£o dessas organiza√ß√µes. Se voc√™ tem 4 times, vai criar um sistema com 4 componentes principais.',
    purpose: 'Conscientizar que a estrutura organizacional influencia diretamente a arquitetura do software.',
    eli5: 'Se 4 amigos fazem um desenho juntos, cada um no seu canto, o desenho vai ter 4 partes separadas. Se eles n√£o conversam, as partes n√£o v√£o combinar!',
    detailed: 'A Lei de Conway afirma que a arquitetura de um sistema ser√° um reflexo da estrutura de comunica√ß√£o da organiza√ß√£o. Se times n√£o se comunicam bem, os m√≥dulos que criam tamb√©m n√£o se integram bem. Se a organiza√ß√£o √© hier√°rquica, o software ser√° hier√°rquico. Isso tem implica√ß√µes pr√°ticas: quer mudar a arquitetura? Talvez precise mudar a estrutura do time. √â a base do conceito de "Inverse Conway Maneuver" - estruture os times de acordo com a arquitetura desejada.',
    relatedHeuristics: ['brooks-law', 'ubiquitous-language'],
    youtubeVideos: [],
  },
  {
    id: 'pola',
    title: 'Principle of Least Astonishment',
    subtitle: 'O sistema deve se comportar como esperado',
    category: 'design',
    icon: 'FaLightbulb',
    shortDescription: 'As coisas devem funcionar da maneira que as pessoas esperam.',
    inventor: 'Comunidade de Design de Software',
    year: 'Anos 70',
    history: 'Este princ√≠pio emergiu da experi√™ncia pr√°tica de design de interfaces e APIs. Desenvolvedores perceberam que quando o comportamento √© inesperado, bugs e frustra√ß√µes aumentam dramaticamente.',
    purpose: 'Criar sistemas intuitivos que se comportam de acordo com as expectativas dos usu√°rios.',
    eli5: 'Se voc√™ v√™ um bot√£o vermelho grande, espera que ele fa√ßa algo importante, tipo parar algo. Se ele s√≥ muda a cor da tela, voc√™ fica confuso!',
    detailed: 'O Princ√≠pio da Menor Surpresa afirma que um sistema deve se comportar de maneira consistente com o que usu√°rios (ou desenvolvedores) razoavelmente esperam. Viola√ß√µes comuns: fun√ß√µes com nomes enganosos, bot√µes que fazem algo inesperado, APIs que retornam tipos diferentes dependendo do input. Siga conven√ß√µes, mantenha consist√™ncia, e fa√ßa o √≥bvio √≥bvio.',
    relatedHeuristics: [],
    youtubeVideos: [],
  },
  {
    id: 'bus-factor',
    title: 'Bus Factor',
    subtitle: 'Quantas pessoas podem ser atropeladas sem parar o projeto',
    category: 'team',
    icon: 'FaBus',
    shortDescription: 'O n√∫mero m√≠nimo de pessoas que precisam sair para que o projeto pare.',
    inventor: 'Comunidade de Desenvolvimento de Software',
    year: 'Anos 90',
    history: 'O termo (√†s vezes chamado de "Truck Factor") surgiu de conversas sobre risco em projetos de software. A pergunta √©: "Quantas pessoas precisam ser atropeladas por um √¥nibus para que o projeto n√£o possa continuar?"',
    purpose: 'Medir e mitigar o risco de concentra√ß√£o de conhecimento em poucas pessoas.',
    eli5: 'Se s√≥ uma pessoa sabe fazer bolo na sua casa e ela viaja, ningu√©m come bolo! Ruim, n√©? √â melhor que v√°rias pessoas saibam fazer.',
    detailed: 'Bus Factor (ou Truck Factor) mede o risco de concentra√ß√£o de conhecimento. Um bus factor de 1 significa que se uma pessoa sair, o projeto pode parar. Bus factor alto √© melhor - significa que o conhecimento est√° distribu√≠do. Para aumentar: documenta√ß√£o, pair programming, rota√ß√£o de tarefas, code reviews, e compartilhamento ativo de conhecimento. Silos de conhecimento s√£o perigosos!',
    relatedHeuristics: ['knowledge-silos', 'brooks-law'],
    youtubeVideos: [],
  },
  {
    id: 'ubiquitous-language',
    title: 'Ubiquitous Language',
    subtitle: 'Todos falam a mesma l√≠ngua no projeto',
    category: 'architecture',
    icon: 'FaBook',
    shortDescription: 'Use os mesmos termos no c√≥digo, documenta√ß√£o e conversas.',
    inventor: 'Eric Evans',
    year: '2003',
    history: 'Eric Evans introduziu este conceito em seu livro "Domain-Driven Design". Ele percebeu que confus√£o na terminologia era uma fonte maior de bugs e mal-entendidos em projetos.',
    purpose: 'Criar uma linguagem comum entre todos os envolvidos no projeto.',
    eli5: 'Se sua fam√≠lia chama o controle remoto de "controle", n√£o comece a chamar de "clicker". Todo mundo vai ficar confuso!',
    detailed: 'Linguagem Ub√≠qua √© um conceito do Domain-Driven Design que prop√µe que todos os envolvidos no projeto (desenvolvedores, domain experts, usu√°rios) usem exatamente os mesmos termos para os mesmos conceitos. Se o neg√≥cio chama algo de "Pedido", n√£o chame de "Order" no c√≥digo e "Solicita√ß√£o" na documenta√ß√£o. Os nomes das classes, m√©todos, vari√°veis e conversas devem todos usar o mesmo vocabul√°rio. Isso reduz drasticamente mal-entendidos.',
    relatedHeuristics: ['conways-law'],
    youtubeVideos: [],
  },
  {
    id: 'knowledge-silos',
    title: 'Knowledge Silos',
    subtitle: 'Quando conhecimento fica preso em uma pessoa ou grupo',
    category: 'team',
    icon: 'FaLock',
    shortDescription: 'Conhecimento cr√≠tico concentrado em poucas pessoas.',
    inventor: 'Conceito de Gest√£o Organizacional',
    year: 'N/A',
    history: 'O conceito de silos vem da gest√£o organizacional, referindo-se a departamentos isolados. Em software, refere-se a conhecimento que fica "preso" com indiv√≠duos ou times espec√≠ficos.',
    purpose: 'Identificar e eliminar concentra√ß√£o perigosa de conhecimento.',
    eli5: '√â como se s√≥ voc√™ soubesse onde est√° escondido o chocolate. Se voc√™ sair de casa, ningu√©m acha! Melhor contar para todo mundo.',
    detailed: 'Knowledge Silos acontecem quando informa√ß√£o cr√≠tica est√° concentrada em poucas pessoas e n√£o √© compartilhada. Isso cria risco (relacionado ao Bus Factor), dificulta colabora√ß√£o, e cria gargalos. Causas: falta de documenta√ß√£o, pessoas trabalhando isoladamente, falta de pair programming, cultura de "her√≥i". Solu√ß√µes: documenta√ß√£o, code reviews, rota√ß√£o de tarefas, pair/mob programming, e cultura de compartilhamento.',
    relatedHeuristics: ['bus-factor'],
    youtubeVideos: [],
  },
  {
    id: 'shotgun-surgery',
    title: 'Shotgun Surgery',
    subtitle: 'Uma pequena mudan√ßa requer altera√ß√µes em muitos lugares',
    category: 'design',
    icon: 'FaBomb',
    shortDescription: 'Quando mudar uma coisa exige mexer em mil lugares diferentes.',
    inventor: 'Martin Fowler',
    year: '1999',
    history: 'Martin Fowler descreveu este code smell em "Refactoring: Improving the Design of Existing Code". O nome vem da imagem de uma espingarda (shotgun) que espalha o impacto em uma √°rea ampla.',
    purpose: 'Identificar c√≥digo onde responsabilidades est√£o espalhadas demais.',
    eli5: 'Imagina que para trocar de roupa, voc√™ precisa mudar tamb√©m as cortinas, os len√ß√≥is e o tapete porque tudo tem que combinar. Cansativo, n√©?',
    detailed: 'Shotgun Surgery √© um code smell onde fazer uma mudan√ßa simples requer altera√ß√µes espalhadas por muitos m√≥dulos diferentes. Isso acontece quando uma responsabilidade est√° fragmentada pelo sistema. Exemplo: mudar um formato de data exige alterar 20 arquivos. Isso aumenta o risco de bugs (esquecer um lugar) e o custo de manuten√ß√£o. Solu√ß√£o: refatorar para centralizar a responsabilidade em um √∫nico lugar.',
    relatedHeuristics: ['srp', 'code-churn', 'change-amplification'],
    youtubeVideos: [],
  },
  {
    id: 'data-clumps',
    title: 'Data Clumps',
    subtitle: 'Dados que sempre aparecem juntos devem ficar juntos',
    category: 'design',
    icon: 'FaObjectGroup',
    shortDescription: 'Se voc√™ sempre usa dados juntos, agrupe-os em uma estrutura.',
    inventor: 'Martin Fowler',
    year: '1999',
    history: 'Martin Fowler identificou este code smell em seu livro sobre refactoring. Ele notou que dados que sempre aparecem juntos t√™m um relacionamento que deve ser formalizado.',
    purpose: 'Identificar e agrupar dados relacionados em estruturas coesas.',
    eli5: 'Se voc√™ sempre leva o l√°pis, a borracha e o apontador juntos, que tal colocar tudo em um estojo?',
    detailed: 'Data Clumps acontecem quando o mesmo grupo de dados aparece junto em muitos lugares: mesmos par√¢metros em v√°rias fun√ß√µes, mesmos campos em v√°rias classes. Exemplo: voc√™ sempre passa "rua, numero, cidade, cep" juntos. Isso indica que esses dados t√™m um relacionamento e devem ser agrupados em uma classe ou struct (ex: Endereco). Isso reduz repeti√ß√£o, melhora legibilidade, e facilita mudan√ßas futuras.',
    relatedHeuristics: ['srp', 'primitive-obsession'],
    youtubeVideos: [],
  },
  {
    id: 'change-amplification',
    title: 'Change Amplification',
    subtitle: 'Uma pequena mudan√ßa vira uma saga gigante',
    category: 'complexity',
    icon: 'FaArrowUp',
    shortDescription: 'Quando mudan√ßas simples requerem esfor√ßo desproporcional.',
    inventor: 'John Ousterhout',
    year: '2018',
    history: 'John Ousterhout descreveu Change Amplification em "A Philosophy of Software Design" como um dos principais sintomas de complexidade em software.',
    purpose: 'Identificar quando o custo de mudan√ßas est√° desproporcional ao seu tamanho conceitual.',
    eli5: '√â como quando voc√™ quer mudar um brinquedo de lugar, mas precisa mover a cama, o arm√°rio, a mesa... Tudo por causa de um brinquedinho!',
    detailed: 'Change Amplification acontece quando uma mudan√ßa conceitualmente simples requer modifica√ß√µes em muitos lugares diferentes do c√≥digo. √â similar ao Shotgun Surgery, mas foca no custo ampliado da mudan√ßa. Exemplo: adicionar um novo campo em um formul√°rio requer mudan√ßas no frontend, backend, banco de dados, valida√ß√£o, testes, etc. Design modular e boas abstra√ß√µes reduzem change amplification.',
    relatedHeuristics: ['shotgun-surgery', 'cognitive-complexity'],
    youtubeVideos: [],
  },
  {
    id: 'primitive-obsession',
    title: 'Primitive Obsession',
    subtitle: 'Usar tipos primitivos quando deveria criar tipos espec√≠ficos',
    category: 'design',
    icon: 'FaCube',
    shortDescription: 'Se um dado tem l√≥gica pr√≥pria, crie um tipo para ele.',
    inventor: 'Martin Fowler',
    year: '1999',
    history: 'Martin Fowler identificou este code smell ao observar que desenvolvedores frequentemente usam strings e n√∫meros para representar conceitos do dom√≠nio que mereciam tipos pr√≥prios.',
    purpose: 'Criar tipos espec√≠ficos para conceitos do dom√≠nio ao inv√©s de usar primitivos.',
    eli5: 'Em vez de s√≥ falar "aquele n√∫mero ali", d√™ um nome: "seu telefone", "sua idade", "o pre√ßo". Fica mais claro!',
    detailed: 'Primitive Obsession √© usar tipos primitivos (string, int, etc.) para representar conceitos do dom√≠nio que t√™m sua pr√≥pria l√≥gica e regras. Exemplo: usar string para CPF, Email, CEP. Problemas: valida√ß√£o espalhada, sem type safety, dif√≠cil de mudar. Solu√ß√£o: criar tipos espec√≠ficos (classes ou value objects) que encapsulam a valida√ß√£o e comportamento. CPF vira uma classe com valida√ß√£o interna, n√£o apenas uma string.',
    relatedHeuristics: ['data-clumps', 'srp'],
    youtubeVideos: [],
  },
  {
    id: 'temporal-coupling',
    title: 'Temporal Coupling',
    subtitle: 'Quando coisas s√≥ funcionam em uma ordem espec√≠fica',
    category: 'design',
    icon: 'FaCalendar',
    shortDescription: 'Depend√™ncias escondidas na ordem de execu√ß√£o.',
    inventor: 'Steve McConnell',
    year: '1993',
    history: 'Steve McConnell discutiu este conceito em "Code Complete". Ele observou que quando a ordem de chamadas importa mas n√£o √© expl√≠cita, bugs surgem facilmente.',
    purpose: 'Identificar e eliminar depend√™ncias ocultas na ordem de execu√ß√£o.',
    eli5: '√â como ter que colocar o sapato ANTES da meia. N√£o faz sentido! As coisas devem poder acontecer na ordem que fizer mais sentido.',
    detailed: 'Temporal Coupling acontece quando m√©todos ou fun√ß√µes devem ser chamados em uma ordem espec√≠fica, mas essa restri√ß√£o n√£o √© √≥bvia no c√≥digo. Exemplo: voc√™ tem que chamar `connect()` antes de `send()`, mas nada no c√≥digo impede de chamar na ordem errada. Isso causa bugs sutis. Solu√ß√µes: usar builder patterns, fazer objetos imut√°veis que j√° nascem v√°lidos, ou redesenhar a API para tornar a ordem impl√≠cita.',
    relatedHeuristics: [],
    youtubeVideos: [],
  },
];
